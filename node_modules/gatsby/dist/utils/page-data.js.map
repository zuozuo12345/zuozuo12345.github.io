{"version":3,"file":"page-data.js","names":["readPageData","publicDir","pagePath","filePath","generatePageDataPath","rawPageData","fs","readFile","JSON","parse","removePageData","existsSync","remove","Promise","resolve","pageDataExists","lmdbPageQueryResultsCache","getLMDBPageQueryResultsCache","GatsbyCacheLmdbImpl","require","default","name","encoding","init","savePageQueryResultsPromise","waitUntilPageQueryResultsAreStored","savePageQueryResult","programDir","stringifiedResult","isLmdbStore","set","pageQueryResultsPath","path","join","replace","outputFile","readPageQueryResult","get","Error","writePageData","pageData","result","outputFilePath","body","constructPageDataString","pageDataSize","Buffer","byteLength","store","dispatch","type","payload","size","pageDataHash","createContentDigest","isFlushPending","isFlushing","isFlushEnqueued","staleNodeManifests","maxManifestIdsToLog","flush","parentSpan","pendingPageDataWrites","pages","program","staticQueriesByTemplate","queries","nodeManifests","getState","isBuild","_","pagePaths","writePageDataActivity","nodeManifestPagePathMap","processNodeManifests","reporter","createProgress","id","start","length","warn","map","n","manifestId","slice","flushQueue","fastq","cb","page","process","env","GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND","query","trackedQueries","hasFlag","dirty","FLAG_DIRTY_NEW_PAGE","setImmediate","getPageMode","staticQueryHashes","componentPath","directory","tick","websocketManager","emitPageData","push","idle","drain","end","enqueueFlush","isWebpackStatusPending","handleStalePageData","pathExists","activity","activityTimer","pageDataFilesFromPreviousBuilds","reject","results","Set","stream","fsWalkStream","on","data","add","e","expectedPageDataFiles","forEach","deletionPromises","pageDataFilePath","has","all"],"sources":["../../src/utils/page-data.ts"],"sourcesContent":["import { walkStream as fsWalkStream, Entry } from \"@nodelib/fs.walk\"\nimport fs from \"fs-extra\"\nimport reporter from \"gatsby-cli/lib/reporter\"\nimport fastq from \"fastq\"\nimport path from \"path\"\nimport { createContentDigest, generatePageDataPath } from \"gatsby-core-utils\"\nimport { websocketManager } from \"./websocket-manager\"\nimport { isWebpackStatusPending } from \"./webpack-status\"\nimport { store } from \"../redux\"\nimport { hasFlag, FLAG_DIRTY_NEW_PAGE } from \"../redux/reducers/queries\"\nimport { isLmdbStore } from \"../datastore\"\nimport type GatsbyCacheLmdb from \"./cache-lmdb\"\nimport {\n  constructPageDataString,\n  reverseFixedPagePath,\n  IPageData,\n} from \"./page-data-helpers\"\nimport { Span } from \"opentracing\"\n\nexport { reverseFixedPagePath }\nimport { processNodeManifests } from \"../utils/node-manifest\"\nimport { IExecutionResult } from \"../query/types\"\nimport { getPageMode } from \"./page-mode\"\n\nexport interface IPageDataWithQueryResult extends IPageData {\n  result: IExecutionResult\n}\n\nexport async function readPageData(\n  publicDir: string,\n  pagePath: string\n): Promise<IPageDataWithQueryResult> {\n  const filePath = generatePageDataPath(publicDir, pagePath)\n  const rawPageData = await fs.readFile(filePath, `utf-8`)\n\n  return JSON.parse(rawPageData)\n}\n\nexport async function removePageData(\n  publicDir: string,\n  pagePath: string\n): Promise<void> {\n  const filePath = generatePageDataPath(publicDir, pagePath)\n\n  if (fs.existsSync(filePath)) {\n    return await fs.remove(filePath)\n  }\n\n  return Promise.resolve()\n}\n\nexport function pageDataExists(publicDir: string, pagePath: string): boolean {\n  return fs.existsSync(generatePageDataPath(publicDir, pagePath))\n}\n\nlet lmdbPageQueryResultsCache: GatsbyCacheLmdb\nfunction getLMDBPageQueryResultsCache(): GatsbyCacheLmdb {\n  if (!lmdbPageQueryResultsCache) {\n    const GatsbyCacheLmdbImpl = require(`./cache-lmdb`).default\n    lmdbPageQueryResultsCache = new GatsbyCacheLmdbImpl({\n      name: `internal-tmp-query-results`,\n      encoding: `string`,\n    }).init()\n  }\n  return lmdbPageQueryResultsCache\n}\n\nlet savePageQueryResultsPromise = Promise.resolve()\n\nexport function waitUntilPageQueryResultsAreStored(): Promise<void> {\n  return savePageQueryResultsPromise\n}\n\nexport async function savePageQueryResult(\n  programDir: string,\n  pagePath: string,\n  stringifiedResult: string\n): Promise<void> {\n  if (isLmdbStore()) {\n    savePageQueryResultsPromise = getLMDBPageQueryResultsCache().set(\n      pagePath,\n      stringifiedResult\n    ) as Promise<void>\n  } else {\n    const pageQueryResultsPath = path.join(\n      programDir,\n      `.cache`,\n      `json`,\n      `${pagePath.replace(/\\//g, `_`)}.json`\n    )\n    await fs.outputFile(pageQueryResultsPath, stringifiedResult)\n  }\n}\n\nexport async function readPageQueryResult(\n  publicDir: string,\n  pagePath: string\n): Promise<string | Buffer> {\n  if (isLmdbStore()) {\n    const stringifiedResult = await getLMDBPageQueryResultsCache().get(pagePath)\n    if (typeof stringifiedResult === `string`) {\n      return stringifiedResult\n    }\n    throw new Error(`Couldn't find temp query result for \"${pagePath}\".`)\n  } else {\n    const pageQueryResultsPath = path.join(\n      publicDir,\n      `..`,\n      `.cache`,\n      `json`,\n      `${pagePath.replace(/\\//g, `_`)}.json`\n    )\n    return fs.readFile(pageQueryResultsPath)\n  }\n}\n\nexport async function writePageData(\n  publicDir: string,\n  pageData: IPageData\n): Promise<string> {\n  const result = await readPageQueryResult(publicDir, pageData.path)\n\n  const outputFilePath = generatePageDataPath(publicDir, pageData.path)\n\n  const body = constructPageDataString(pageData, result)\n\n  // transform asset size to kB (from bytes) to fit 64 bit to numbers\n  const pageDataSize = Buffer.byteLength(body) / 1000\n\n  store.dispatch({\n    type: `ADD_PAGE_DATA_STATS`,\n    payload: {\n      pagePath: pageData.path,\n      filePath: outputFilePath,\n      size: pageDataSize,\n      pageDataHash: createContentDigest(body),\n    },\n  })\n\n  await fs.outputFile(outputFilePath, body)\n  return body\n}\n\nlet isFlushPending = false\nlet isFlushing = false\n\nexport function isFlushEnqueued(): boolean {\n  return isFlushPending\n}\n\nlet staleNodeManifests = false\nconst maxManifestIdsToLog = 50\n\nexport async function flush(parentSpan?: Span): Promise<void> {\n  if (isFlushing) {\n    // We're already in the middle of a flush\n    return\n  }\n  await waitUntilPageQueryResultsAreStored()\n  isFlushPending = false\n  isFlushing = true\n  const {\n    pendingPageDataWrites,\n    pages,\n    program,\n    staticQueriesByTemplate,\n    queries,\n    nodeManifests,\n  } = store.getState()\n  const isBuild = program?._?.[0] !== `develop`\n\n  const { pagePaths } = pendingPageDataWrites\n  let writePageDataActivity\n\n  let nodeManifestPagePathMap\n\n  if (pagePaths.size > 0) {\n    // we process node manifests in this location because we need to add the manifestId to the page data.\n    // We use this manifestId to determine if the page data is up to date when routing. Here we create a map of \"pagePath\": \"manifestId\" while processing and writing node manifest files.\n    // We only do this when there are pending page-data writes because otherwise we could flush pending createNodeManifest calls before page-data.json files are written. Which means those page-data files wouldn't have the corresponding manifest id's written to them.\n    nodeManifestPagePathMap = await processNodeManifests()\n\n    writePageDataActivity = reporter.createProgress(\n      `Writing page-data.json files to public directory`,\n      pagePaths.size,\n      0,\n      { id: `write-page-data-public-directory`, parentSpan }\n    )\n    writePageDataActivity.start()\n  } else if (nodeManifests.length > 0 && staleNodeManifests) {\n    staleNodeManifests = false\n\n    reporter.warn(\n      `[gatsby] node manifests were created but no page-data.json files were written, so manifest ID's were not added to page-data.json files. This may be a bug or it may be due to a source plugin creating a node manifest for a node that did not change. Node manifest IDs: ${nodeManifests\n        .map(n => n.manifestId)\n        .slice(0, maxManifestIdsToLog)\n        .join(`,`)}${\n        nodeManifests.length > maxManifestIdsToLog\n          ? ` There were ${\n              nodeManifests.length - maxManifestIdsToLog\n            } additional ID's that were not logged due to output length.`\n          : ``\n      }`\n    )\n\n    nodeManifestPagePathMap = await processNodeManifests()\n  } else if (nodeManifests.length > 0) {\n    staleNodeManifests = true\n  }\n\n  const flushQueue = fastq(async (pagePath, cb) => {\n    const page = pages.get(pagePath)\n\n    // It's a gloomy day in Bombay, let me tell you a short story...\n    // Once upon a time, writing page-data.json files were atomic\n    // After this change (#24808), they are not and this means that\n    // between adding a pending write for a page and actually flushing\n    // them, a page might not exist anymore щ（ﾟДﾟщ）\n    // This is why we need this check\n    if (page) {\n      if (page.path && nodeManifestPagePathMap) {\n        page.manifestId = nodeManifestPagePathMap.get(page.path)\n      }\n\n      if (!isBuild && process.env.GATSBY_EXPERIMENTAL_QUERY_ON_DEMAND) {\n        // check if already did run query for this page\n        // with query-on-demand we might have pending page-data write due to\n        // changes in static queries assigned to page template, but we might not\n        // have query result for it\n        const query = queries.trackedQueries.get(page.path)\n        if (!query) {\n          // this should not happen ever\n          throw new Error(\n            `We have a page, but we don't have registered query for it (???)`\n          )\n        }\n\n        if (hasFlag(query.dirty, FLAG_DIRTY_NEW_PAGE)) {\n          // query results are not written yet\n          setImmediate(() => cb(null, true))\n          return\n        }\n      }\n\n      // In develop we rely on QUERY_ON_DEMAND so we just go through\n      // In build we only build these page-json for SSG pages\n      if (!isBuild || (isBuild && getPageMode(page) === `SSG`)) {\n        const staticQueryHashes =\n          staticQueriesByTemplate.get(page.componentPath) || []\n\n        const result = await writePageData(\n          path.join(program.directory, `public`),\n          {\n            ...page,\n            staticQueryHashes,\n          }\n        )\n\n        writePageDataActivity.tick()\n\n        if (!isBuild) {\n          websocketManager.emitPageData({\n            id: pagePath,\n            result: JSON.parse(result) as IPageDataWithQueryResult,\n          })\n        }\n      }\n    }\n\n    store.dispatch({\n      type: `CLEAR_PENDING_PAGE_DATA_WRITE`,\n      payload: {\n        page: pagePath,\n      },\n    })\n\n    // `setImmediate` below is a workaround against stack overflow\n    // occurring when there are many non-SSG pages\n    setImmediate(() => cb(null, true))\n    return\n  }, 25)\n\n  for (const pagePath of pagePaths) {\n    flushQueue.push(pagePath, () => {})\n  }\n\n  if (!flushQueue.idle()) {\n    await new Promise(resolve => {\n      flushQueue.drain = resolve as () => unknown\n    })\n  }\n  if (writePageDataActivity) {\n    writePageDataActivity.end()\n  }\n\n  isFlushing = false\n\n  return\n}\n\nexport function enqueueFlush(parentSpan?: Span): void {\n  if (isWebpackStatusPending()) {\n    isFlushPending = true\n  } else {\n    flush(parentSpan)\n  }\n}\n\nexport async function handleStalePageData(parentSpan: Span): Promise<void> {\n  if (!(await fs.pathExists(`public/page-data`))) {\n    return\n  }\n\n  // public directory might have stale page-data files from previous builds\n  // we get the list of those and compare against expected page-data files\n  // and remove ones that shouldn't be there anymore\n\n  const activity = reporter.activityTimer(`Cleaning up stale page-data`, {\n    parentSpan,\n  })\n  activity.start()\n\n  const pageDataFilesFromPreviousBuilds = await new Promise<Set<string>>(\n    (resolve, reject) => {\n      const results = new Set<string>()\n\n      const stream = fsWalkStream(`public/page-data`)\n\n      stream.on(`data`, (data: Entry) => {\n        if (data.name === `page-data.json`) {\n          results.add(data.path)\n        }\n      })\n\n      stream.on(`error`, e => {\n        reject(e)\n      })\n\n      stream.on(`end`, () => resolve(results))\n    }\n  )\n\n  const expectedPageDataFiles = new Set<string>()\n  store.getState().pages.forEach(page => {\n    expectedPageDataFiles.add(generatePageDataPath(`public`, page.path))\n  })\n\n  const deletionPromises: Array<Promise<void>> = []\n  pageDataFilesFromPreviousBuilds.forEach(pageDataFilePath => {\n    if (!expectedPageDataFiles.has(pageDataFilePath)) {\n      deletionPromises.push(fs.remove(pageDataFilePath))\n    }\n  })\n\n  await Promise.all(deletionPromises)\n\n  activity.end()\n}\n"],"mappings":"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"}